using YawnMassage.Common.Domain.Contexts;
using YawnMassage.Common.Domain.Contracts;
using YawnMassage.Common.Domain.Documents;
using YawnMassage.Common.Domain.Dto;
using YawnMassage.Common.Domain.Dto.ResultSet;
using YawnMassage.Common.Domain.Exceptions;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace YawnMassage.Common.Services
{
    /// <summary>
    /// This service introduces automatic partition management, audit fields and soft-delete concepts
    /// on top of plain document db service.
    /// </summary>
    public class AuditedDocumentDbService : IAuditedDocumentDbService
    {
        private readonly IDocumentDbService _documentDbService;
        private readonly string _collectionId;
        public readonly RequestContext _requestContext;
        private readonly bool _useNeutralGroup;

        public AuditedDocumentDbService(IDocumentDbService documentDbService, DbInfo dbInfo, RequestContext requestContext, bool useNeutralGroup)
        {
            _documentDbService = documentDbService;
            _collectionId = dbInfo.CollectionId;

            _requestContext = requestContext;
            _useNeutralGroup = useNeutralGroup;
        }

        public virtual async Task<DocumentUpdateResultDto> CreateDocumentAsync<T>(T document) where T : AuditedDocumentBase, new()
        {
            if (!string.IsNullOrEmpty(document.PartitionKey))
                throw new Exception("Cannot set PartitionKey of document. It will be automatically assigned.");

            string partitionKey = GetPartitionKey();
            return await CreateDocumentByPartitionAsync(document, partitionKey);
        }

        public virtual async Task<DocumentUpdateResultDto> CreateDocumentAsync<T>(T document, string partitionKey) where T : AuditedDocumentBase, new()
        {
            return await CreateDocumentByPartitionAsync(document, partitionKey);
        }

        private async Task<DocumentUpdateResultDto> CreateDocumentByPartitionAsync<T>(T document, string paritionKey) where T : AuditedDocumentBase, new()
        {
            if (!string.IsNullOrEmpty(document.GroupId) && document.GroupId != GetGroupId())
                throw new UnauthorizedAccessException("GroupId context mismatch.");

            document.PartitionKey = paritionKey;
            document.GroupId = GetGroupId();
            document.CreatedById = document.UpdatedById = _requestContext.UserId;
            document.CreatedByName = document.UpdatedByName = _requestContext.UserDisplayName;
            document.CreatedOnUtc = document.UpdatedOnUtc = DateTime.UtcNow;

            var result = await _documentDbService.CreateDocumentAsync(_collectionId, document.PartitionKey, document);

            //Update the in-memory object with the id and etag generated from the db.
            document.Id = result.Id;
            document.ETag = result.ETag;

            result.UpdatedById = document.UpdatedById;
            result.UpdatedByName = document.UpdatedByName;
            result.UpdatedOnUtc = document.UpdatedOnUtc;

            return result;
        }

        public virtual async Task<DocumentUpdateResultDto> ReplaceDocumentAsync<T>(T document) where T : AuditedDocumentBase, new()
        {
            if (string.IsNullOrEmpty(document.Id))
                throw new Exception("Cannot replace document with empty 'id'");

            if (document.GroupId != GetGroupId())
                throw new UnauthorizedAccessException("GroupId context mismatch.");

            document.GroupId = GetGroupId();
            document.UpdatedById = _requestContext.UserId;
            document.UpdatedByName = _requestContext.UserDisplayName;
            document.UpdatedOnUtc = DateTime.UtcNow;

            var result = await _documentDbService.ReplaceDocumentAsync(_collectionId, document.PartitionKey, document.Id, document, document.ETag);

            result.UpdatedById = document.UpdatedById;
            result.UpdatedByName = document.UpdatedByName;
            result.UpdatedOnUtc = document.UpdatedOnUtc;

            //Update the in-memory object with the etag generated by the db.
            document.ETag = result.ETag;

            return result;
        }

        public virtual async Task DeleteDocumentAsync<T>(T document) where T : AuditedDocumentBase, new()
        {
            await _documentDbService.DeleteDocumentAsync(_collectionId, document.PartitionKey, document.Id);
        }

        public async Task DeleteDocumentByIdAsync(string documentId)
        {
            await _documentDbService.DeleteDocumentAsync(_collectionId, _requestContext.GroupId, documentId);
        }

        public virtual async Task<T> GetDocumentAsync<T>(string documentId) where T : AuditedDocumentBase, new()
        {
            var partitionKey = GetPartitionKey();
            var document = await _documentDbService.GetDocumentAsync<T>(_collectionId, partitionKey, documentId);

            if (document == null)
                throw new DocumentNotFoundException();
            else if (document.IsDeleted)
                throw new DocumentAlreadyDeletedException();

            return document;
        }

        public virtual async Task<bool> DocumentExistsAsync<T>(string documentId) where T : AuditedDocumentBase, new()
        {
            var partitionKey = GetPartitionKey();
            return await _documentDbService.DocumentExistsAsync(_collectionId, partitionKey, documentId);
        }

        public virtual async Task SoftDeleteDocumentsAsync<T>(params string[] documentIds) where T : AuditedDocumentBase, new()
        {
            var deleteTasks = new List<Task>();
            var singleDocumentDelete = documentIds.Count() == 1;
            var partitionKey = GetPartitionKey();

            foreach (var documentId in documentIds)
            {
                var document = await _documentDbService.GetDocumentAsync<T>(_collectionId, partitionKey, documentId);

                if (singleDocumentDelete && document == null)
                    throw new DocumentNotFoundException();
                else if (singleDocumentDelete && document.IsDeleted)
                    throw new DocumentAlreadyDeletedException();

                if (document != null && !document.IsDeleted)
                {
                    document.IsDeleted = true;
                    await ReplaceDocumentAsync(document);
                }
            }

            await Task.WhenAll(deleteTasks);
        }

        public virtual async Task<TResult> FirstOrDefaultAsync<T, TResult>(Func<IQueryable<T>, IQueryable<TResult>> query, bool includeDeleted = false) where T : AuditedDocumentBase, new()
        {
            var partitionKey = GetPartitionKey();
            var criteria = new ResultSetCriteria { Limit = 1, IncludeDeleted = includeDeleted };
            var resultSet = await GetDocumentsWithPagingAsync(query, criteria);
            return resultSet.Results.FirstOrDefault();
        }

        public virtual async Task<List<TResult>> GetDocumentsAsync<T, TResult>(Func<IQueryable<T>, IQueryable<TResult>> query, 
            bool includeDeleted = false, Dictionary<string, object> arrayContainsReplacements = null) where T : AuditedDocumentBase, new()
        {
            var criteria = new ResultSetCriteria { IncludeDeleted = includeDeleted };
            var resultSet = await GetDocumentsWithPagingAsync(query, criteria, arrayContainsReplacements);
            return resultSet.Results;
        }

        public virtual async Task<List<TResult>> GetDocumentsAsync<T, TResult>(Func<IQueryable<T>, IQueryable<TResult>> query,
            string partitionKey, bool includeDeleted = false, Dictionary<string, object> arrayContainsReplacements = null) where T : AuditedDocumentBase, new()
        {
            var criteria = new ResultSetCriteria { IncludeDeleted = includeDeleted };
            var resultSet = await GetDocumentsWithPagingAsync(query, criteria, partitionKey, arrayContainsReplacements);
            return resultSet.Results;
        }

        public virtual async Task<bool> AnyAsync<T>(Func<IQueryable<T>, IQueryable<T>> query, bool includeDeleted = false) where T : AuditedDocumentBase, new()
        {
            var criteria = new ResultSetCriteria { Limit = 1, IncludeDeleted = includeDeleted };
            var resultSet = await GetDocumentsWithPagingAsync<T, string>(q => query(q).Select(d => d.Id), criteria);
            return resultSet.Results.Count > 0;
        }

        public virtual async Task<PagedQueryResultSet<TResult>> GetDocumentsWithPagingAsync<T, TResult>(
            Func<IQueryable<T>, IQueryable<TResult>> query,
            ResultSetCriteria criteria, Dictionary<string, object> arrayContainsReplacements = null) where T : AuditedDocumentBase, new()
        {
            var partitionKey = GetPartitionKey();

            var type = (new T()).DocType;
            var resultSet = await _documentDbService.GetDocumentsWithPagingAsync<T, TResult>(_collectionId, partitionKey,
                q => query(q.Where(doc => doc.DocType == type && (criteria.IncludeDeleted || !doc.IsDeleted))),
                criteria, arrayContainsReplacements);

            return resultSet;
        }

        public virtual async Task<PagedQueryResultSet<TResult>> GetDocumentsWithPagingAsync<T, TResult>(
           Func<IQueryable<T>, IQueryable<TResult>> query,
           ResultSetCriteria criteria, string partitionKey, Dictionary<string, object> arrayContainsReplacements = null) where T : AuditedDocumentBase, new()
        {
            var type = (new T()).DocType;
            var resultSet = await _documentDbService.GetDocumentsWithPagingAsync<T, TResult>(_collectionId, partitionKey,
                q => query(q.Where(doc => doc.DocType == type && (criteria.IncludeDeleted || !doc.IsDeleted))),
                criteria, arrayContainsReplacements);

            return resultSet;
        }

        public virtual async Task<TValue> GetStoredProcedureValueAsync<TValue>(string sprocId, params object[] sprocParams)
        {
            return await _documentDbService.ExecuteStoredProcedureAsync<TValue>(_collectionId, sprocId, sprocParams);
        }

        public virtual async Task ExecuteStoredProcedureAsync(string sprocId, params object[] sprocParams)
        {
            await _documentDbService.ExecuteStoredProcedureAsync<object>(_collectionId, sprocId, sprocParams);
        }

        #region Private helper methods

        private string GetPartitionKey()
        {
            return GetGroupId();
        }

        private string GetGroupId()
        {
            return _useNeutralGroup ? "*" : _requestContext.GroupId;
        }

        #endregion
    }
}
